# Семестровое задание

### Реализуйте методы `lower_bound(const T &x)` и `upper_bound(const T &x)` для АВЛ-дерева. 

```cpp
template <typename T>
typename avl_tree<T>::iterator avl_tree<T>::lower_bound(const T& x) const {
    basenode* node = header.left; // Начинаем с корня дерева
    basenode* ans = nullptr; // Переменная для хранения ответа

    while (node != nullptr) {
        if (static_cast<bstnode*>(node)->key >= x) { // Если ключ текущего узла больше или равен x
            ans = node; // Сохраняем текущий узел как потенциальный ответ
            node = node->left; // Переходим в левое поддерево для поиска более близкого элемента
        } else {
            node = node->right; // Иначе переходим в правое поддерево
        }
    }

    if (ans == nullptr) {
        // Если ответ не найден (дерево пустое или все элементы меньше x),
        // возвращаем итератор, указывающий на конец дерева
        return iterator(nullptr);
    }

    // Возвращаем итератор, указывающий на найденный узел
    return iterator(ans);
}

template <typename T>
typename avl_tree<T>::iterator avl_tree<T>::upper_bound(const T& x) const {
    basenode* node = header.left; // Начинаем с корня дерева
    basenode* ans = nullptr; // Переменная для хранения ответа

    while (node != nullptr) {
        if (static_cast<bstnode*>(node)->key > x) { // Если ключ текущего узла больше x
            ans = node; // Сохраняем текущий узел как потенциальный ответ
            node = node->left; // Переходим в левое поддерево для поиска более близкого элемента
        } else {
            node = node->right; // Иначе переходим в правое поддерево
        }
    }

    if (ans == nullptr) {
        // Если ответ не найден (дерево пустое или все элементы меньше или равны x),
        // возвращаем итератор, указывающий на конец дерева
        return iterator(nullptr);
    }

    // Возвращаем итератор, указывающий на найденный узел
    return iterator(ans);
}

```

+ Оба метода (`lower_bound` и `upper_bound`) являются методами класса `avl_tree<T>` и возвращают итераторы на элементы в дереве.

+ Переменная `node` инициализируется указателем на левый потомок корневого узла, чтобы начать поиск элемента с верхней части дерева.

+ Переменная `ans` инициализируется как `nullptr`, чтобы сохранить найденный элемент (если он будет найден).

+ Цикл `while` выполняется до тех пор, пока `node` не станет равным `nullptr`. В каждой итерации цикла происходит следующее:
    + Проверяется условие: если ключ текущего узла больше или равен `x` (в `lower_bound`) или строго больше `x` (в `upper_bound`).
    + Если условие выполняется, текущий узел сохраняется в `ans` и переход осуществляется в левое поддерево для поиска более близкого элемента.
    + Если условие не выполняется, переход осуществляется в правое поддерево.

+ После завершения цикла проверяется значение `ans`. Если `ans` остается равным `nullptr`, значит, не был найден ни один элемент, удовлетворяющий условию, и возвращается итератор, указывающий на конец дерева (`nullptr`). В противном случае возвращается итератор, указывающий на найденный узел (`ans`).


### Кроме этого, реализуйте операторы присваивания и копирующие конструкторы с семантикой копирования и с семантикой перемещения.
