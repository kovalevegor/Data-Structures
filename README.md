# Лабораторная 7 | Дерево Отрезков

#### 1. Запишите комментарии, объясните работу обоих способов построения интервала для метода ```accumulate```

### Построение интервала рекурсивным методом
```cpp
T seg_tree::acumulate(int l, int r) {
    return rec_accum(1, 0, 1 << k, l, r);
}
```
+ ```acumulate``` - метод, который выполняет операцию накопления (accumulate) на диапазоне от ```l``` до ```r```.
+ ```rec_accum``` - вспомогательная рекурсивная функция, которая выполняет накопление на поддереве с корнем в вершине ```v``` и диапазоне от ```vl``` до ```vr```.
+ Возвращает результат накопления.
```cpp
T seg_tree::rec_accum(int v, int vl, int vr, int l, int r) {
    if (l == vl && r == vr) return data[v];
```
+ Если заданный диапазон ```[l, r)``` полностью соответствует текущему узлу ```[vl, vr)```, то возвращается значение ```data[v]``` (подсчитанное значение в текущем узле).
```cpp
int c = (vl + vr) / 2;
if (r <= c) return rec_accum(v * 2, vl, c, l, r);
if (c <= l) return rec_accum(v * 2 + 1, c, vr, l, r);
```
+ Вычисляется середина поддерева как ```c = (vl + vr) / 2```.
+ Если правая граница ```r``` находится до середины ```c```, рекурсивно вызывается ```rec_accum``` для левого поддерева ```v * 2``` с диапазоном ```[vl, c)``` и возвращается результат.
+ Если левая граница ```l``` находится после или на равной позиции с серединой c, рекурсивно вызывается ```rec_accum``` для правого поддерева ```v * 2 + 1``` с диапазоном ```[c, vr)``` и возвращается результат.
```cpp
return op(rec_accum(v * 2, vl, c, l, c), rec_accum(v * 2 + 1, c, vr, c, r));
```
+ Если диапазон ```[l, r)``` перекрывает середину ```c```, выполняется операция ```op``` (которая должна быть определена) над результатами рекурсивного вызова ```rec_accum``` для левого поддерева ```v * 2``` с диапазоном ```[vl, c)``` и правого поддерева ```v * 2 + 1``` с диапазоном ```[c, vr)```.
---
### Процедура построения интервала подъемом по дереву
```cpp
T seg_tree::acumulate(int l, int r) {
    T result = identity_element;
```
+ Инициализация результата значением нулевым нейтральным элементом
```cpp
    l += 1 << k; r += 1 << k;
```
+ Изменение границ интервала, добавляя ```2^k```, для того, чтобы от номеров вершин в исходной последовательности, которые с нуля начинались, перейти к номерам в дереве. После выполнения этиъ действий, ```l``` и ```r``` - это номера в дереве
```cpp
    for (; l < r; l /= 2, r /= 2) {
```
+ Построение интервала подъемом по дереву. Пока левая и правая границы интервала не совпадут
```cpp
        if (l & 1)
            result = op(result, data[l++]);
```
+ Если левая граница нечетная, добавляем значение в результат и увеличиваем ее на 1
```cpp
        if (r & 2)
            result = op(result, data[--r]);
    }
```
+ Если правая граница четная, добавляем значение в результат и уменьшаем ее на 1
```cpp
    return result;
}
```
+ Возвращение результата
---
#### 2. Приведите пример интервала, который можно собрать ровно из ```2r-4``` ранее подсчитанных интервалов, где ```r``` - количество слоев в дереве. 
```

                         136
                /                     \
           58                              78
       /         \                   /          \
   25              33            45               33
 /    \          /    \        /    \           /    \
 9     16     17      16    21      24       9       24
/ \    / \    / \    / \    / \     / \     / \     /  \
4  5  6  10  7  10  8   9  10  11  12  12  6   3   12  12

```

Таким интрвалом является интервал листьев без первого и последнего `[1;15)`

Он составлен из следующих шестри ранее подсчитанных интервалов: 

`33 | 45 | 16 | 9 | 5 | 12`

---

#### 3. Ответьте на следующий вопрос: при реализации какой операции было использовно свойство коммутативности операции? В каком месте программы? Как изменить программу, чтобы она корректно работала для некоммутативных оперций? 


#### 4. Приступите к разработке класс ```seg_tree``` в двух версиях: с рекурсивными методами и с нерукурсивными. Первая версия класс должна содрежать конструктур, виртуальный деструктор (далее предполагается наследование), метод построения дерева, метод изменения одного элемента по его номеру и метод ```top()```, возвращающий значение из корня дерева. 


---

#### 5. Протестируйте разработанные классы, решив задачу 1 (формула из имликаций). Протестировать следует оба класса

---

#### 6. Продолжите разработку класса ```seg_tree```. Добавив в обе версии класса метод ```accumulate```

---


#### 7. Протестируйте разработанные классы, решив задачу 3 (сумма на а отрезке), протестировать следует оба класса

---


#### 8. Создайте наследника от одного из разработанных классов (по своему выбору). В наследуемый класс следует добавить метод first_upper. Протестируйте разработаный класс, решив задачу 2 (как тебе такое, Илон Маск?)

---


#### 9. Решита задачу 7 (к-тая статистика в динамическом массиве)














# SRC 

[Хранение информации в дереве отрезков](https://youtu.be/afRI2x04Pjk)

[Алгоритмы дерева отрезков](https://youtu.be/EGbpBUIfU-k)

[Основные операции над деревом отрезков](https://youtu.be/O9UlDA17P98)

[Использование дерева отрезков](https://youtu.be/JP0e__v1dV0)

[Рекомендации по выполнению заданий](https://youtu.be/6sTL5Z086iU)

[Тренировка по теме "Дерево отрезков"](http://olymp.isu.ru/cgi-bin/new-client?contest_id=67)
