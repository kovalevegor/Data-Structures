# Лекция 2 | Сложность вычислений 

### Градация сложности алгоритмов 

$$
O(n!) \to O(2^n) \to O(n^2) \to O(n*log n) \to O(n) \to O(\sqrt{n}) \to O(log n) \to O(1)
$$

---

#### 1. Один из алгоритмов сортировки имеет среднюю сложность ```nlog n```, а максимальную - ```n^2```, причем максимальная сложность достигается только на упорядоченных или на почти упорядоченных наборах входных данных. Можно ли использовать этот алгоритм в прикладных программах для сортировки нескольких миллионов натруальных чисел? 

В прикладных программах обычно используется максимальная сложность, поэтому этот алгоритм нельзя использовать, так как вероятность того, что набор входных данных будет уже упорядоченным или почти упорядоченным очень высока

---

#### 2. К алгоритму сортировки из предыдущего вопроса можно применить процедуру рэндомизации, которая состоит в том что до начала работы алгоритма выполняется случайная перестановка элементов последователности. Теперь алгоритм будет иметь максимальную сложность, только если после этой неизвестной случайной перестановки последовательность станет упорядоченной или почти упорядоченной. Можно ли использовать алгоритм после такой модификации в прикладных программах для сортировки нескольких натуральных чисел? 

Аалгоритм можно использовать после рэндомизации, т.к. исчезают все закономерности (Колмогоровская сложность) и вероятность получить упорядоченную или почти упорядоченную последовательность очень низка. Ее можно вычислить по формуле вероятности: 1/миллион факториал.

---

#### 3. Рассмотрим следующую задачу. Даны два конечных множества натуральных чисел. Множества заданы перечислением элементов. Требуется найти пересечение мнжеств. Какие параметры будут у функции сложности такого алгоритма? В этой задаче не требуется указывать вид функции сложности, требуется только указать ее параметры. 

Для этой задачи можно использовать разные алгоритмя поиска пересечения двух множеств: нахождения одинаковых элементов в двух разных множествах. Можно использовать, например, простой линейный поиск, тогда параметры у функции сложности будут всего два параметра: значения описывающие размерность каждого множества. Пусть у множества A размерность будет равно n, и у второго множества B размерность будет равна m. ```Тогда параметры функции сложности будут n и m.```

---


#### 4. Для некоторого алгоритма дерево с n вершинами задано списком ребер. Какие параметры будут у функции сложности этого алгоритма? 

Независимо от алгоритма, ```параметром функции сложности обязательно будет n``` - число вершин дерева. Потому что в любое дерево строится в зависимости от количества вершин, а способ задания дерева (графа) не важен, потому что такой тип данных можно либо преобразовать в любой другой. 

---

#### 5. Прогрмма использует одномерный массив из n чисел. Какие фрагметы программы будут иметь сложность O(1)? Ответы требуется обосновать.

+ **Взятие элемента с номером n/2** | ```O(1)``` | Это одна операция, которая не зависит от количества элементов массива.
+ **Нахождение суммы всех элементов** | ```O(n)``` | В данном случает нужно последовательно перебирать все элементы, операция зависит от размерности одномерного массива, поэтому.
+ **Сортировка трех первых элементов массива** | ```O(1)``` | Данный фрагмент зависит от тривиального числа, и так как имеется константа, фрагмент имеет константную сложность.
+ **Разворот массива** | ```O(n)``` | Один из алгоритмов разворота одномерного массива перебирает половину элементов, следовательно, он зависит от n, а констану 2 можно отбросить.
+ **Поиск минимума из первой четверти элементов массива** | ```O(n)``` |Данный фрагмент имеет сложность как и предыдущий  по тем же причинам, только здесь отбрасывается четверть - (n/4).


---

#### 6. Программа использует двумерный квадратный массив из n $\times$ n чисел. Какие фрагменты программы будут иметь сложность O(1)? Ответы требуется обосновать.

+ **Нахождение суммы элементов в первой строке** | ```O(n)``` | Данный фрагмент зависит только от количества столбцов матрицы, когда второй параметр - это константное значение строки, поэтому парметром функции ложности будет только n.
+ **Нахождение суммы элементов в первом столбце** | ```O(n)``` | Здесь все так же, как и в предыдущем фрагменте, только зеркально, линейная сложность
+ **Нахождение минимума на главной диагонали** | ```O(n)``` | Так как матрица квадрантная, жлементы на главной диагонали будут иметь одинаковый индекс строк и столбцов, следовательно, алгоритм зависит от одного параметра n
+ **Транспонирование массива** | ```O(n^2)``` | Для транспонирования матрицы, нужно создать цикл, который будет принимать параметр n, а также вложенный цикл, который тоже зависит от n, следовательно, сложность будет квадратичная
+ **Нахождение произведения угловых элементов** | ```O(1)``` |  Для выполнения данного фрагмента, необходимо обратиться к четырем элементам матрицы, а это действие имеет сложность 4O(1), тогда общая сложность константная
---

#### 7. Упростите следующие оценки:

$$ 
(O(3n^2) + O(n^2log(n)) \times O(2n + 1) 
=(O(n^2) + O(n^2)) \times O(n) = 2O(n^2) \times O(n) = O(n^3)
 $$

---

$$ 
O(n \times log_2n) + O(n \times log_{10}n)
= O(n \times log n) + O(n \times log n) = 2 \times O(n \times log n) = O(n\times log n)
$$

---

$$ 
O((n + m)^2) - O(n^2) - O(m^2)
= O(n^2 + 2nm + m^2) - O(n^2) - O(m^2) = O(n^2 + n \times m + m^2) = O(n^2 + n \times m + m^2)=O(n^2 + m^2)
$$


---

$$ 
O(2^\frac{n}{2})+O(1.5^n)=
O((\sqrt{2})^n+1.5^n)=O(1.4^n + 1.5^n)=
O((\sqrt{2})^n)
$$

---

$$
\sum_{i=1}^{n} O(i)
= O(\int_1^{n+1} x),\mathrm{d}x 
= O(\frac{(n+1)^2}{2}-\frac{1}{2}) = O(n^2)
$$

---

$$
\sum_{i=1}^{n} O(n)/i
=O(\int_1^{n+1}\frac{n}{x},\mathrm{d}x)=O(n\times log(n+1)) = O(n \times logn)
|Ответ: O(n \times logn)
$$

---


#### 8. Оцените максимальную сложность приведенных далее функций на языке C++. Решение должно содержать следующие пункты: аргументы функции сложности, элементарные операции, которые используются для подсчета, подсчет и оценка числа операций. Ответ должен иметь упрощенный вид. 

### 1
```cpp
int foo()
{
    int k = v.size() / 2;
    int ans = 0;
    for (int i = 0; i < k; i++) {
        int s = 0;
        for (int j = 0; j < k; j++) {
            s += v[i + j];
        }
        ans = std::max(ans, s);
    }
    std::cout << ans << std::endl;
}
```

+ Алгоритм находит сумму элементов линейного подмассива, длина которого равна половине заданного. Алгоритм перебирает последовательно половину элементов, начиная с нулевого элемента, и суммирует их. Если такая очередная сумма больше предыдущей, то запоминается эта сумма. 
+ Функция сложности будет иметь вид f(n), где n - размер массива 
+ Будем подсчитывать количество операций суммирования очередного элемента подмассива с переменной суммы
+ Вложенный цикл выполняется $\frac{n}{2}-1$ раз, для каждой итерации внешнего цикла, который тоже выполняется $\frac{n}{2}-1$ раз.
+ Таким образом, сложность алгоритма ```квадратичная```

$$
f(n) = O((\frac{n}{2}-1) \times (\frac{n}{2}-1))=O(\frac{n^2}{4}-n+1)=O(n^2)
$$

---

### 2
```cpp
int prime(int n) {
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0)
                return false;
        }
        return true;
    }
```

+ Алгоритм проверяет число на простоту. Функция перебирает квадраты чисел, начиная с двойки, до n.
+ Функция сложности будет иметь вид f(n), где n - размер массива 
+ Будем считать количество выполнений ```if-statement```
+ Условие в цикле выполняется не больше $\sqrt{n}$ раз
+ Поэтому, сложность алгоритма ```сублинейная```

$$
f(n)=O(\sqrt{n})
$$

---

### 3
```cpp
char max_cnt(std::string s) {
    std::vector<int>v(256);
    for (char sym : s) {
        v[sym]++;
    }
    int ind = 0;
    for (int i = 1; i < 256; i++) {
        if (v[i] > v[ind]) {
            ind = i;
        }
    }
    return ind;
}
```

+ Функция строит вектор из 256 нулей. Затем считает количество повторений символов в строке длиной n. После в цикле из 256 шагов находит кодировку самой часто-встречаемой литеры в строке.
+ Функция сложности будет иметь вид f(n), где n - длина строки
+ будем считать количество действий 
```cpp
v[sym]++;
```
+ Второй цикл учитываться не будет, так как он зависит от константного параметра, поэтому его сложность $O(n)$
+ таким образом, сложность алгоритма - ```линейная```

$$
f(n) = O(n) + O(256) = O(n) + O(1) = O(n)
$$

---

### 4
```cpp
int foo(std::vector<int>& v) {
    int sum = 0;
    for (int i = 0; i < v.size(); i++) {
        for (int j = i + 1; j < v.size(); j++) {
            for (int k = i + 1; k < v.size(); k++) {
                sum += v[j] * v[k];
            }
        }
    }
    return sum;
}
```
+ Алгоритм без особого смысла, считает сумму элемнтов вектора очень много раз.
+ Функция сложности будет иметь вид f(n), где n - размер массива
+ Первый цикл выполняется $n$ раз, второй - $i - 1$ для каждой итерации первого цикла, ну а третий выполняется $i - 1$ раз для каждой итерации второго цикла
+ Будем считать количество выполнений 
```cpp
sum += v[j] * v[k];
```
+ Таким образом, сложность алгоритма будет ```кубическая```: 

$$
\sum_{i=0}^{n-1} \sum_{j=i+1}^{n-1} \sum_{k=i+1}^{n-1} = O(
\int_0^{n} \int_1^{x} \int_1^{y} 1,\mathrm{d}z\mathrm{d}y\mathrm{d}x)=O(
\int_0^{n} \int_1^{x}y,\mathrm{d}y\mathrm{d}x)=O(
\int_0^{n}\frac{n^2-1}{2},\mathrm{d}x)=O(
\frac{n^3-3n^2}{6})
=O(n^3)
$$

---


### 5

```cpp
int foo (std::vector<int>&v){
    int sum = 0;
    for (int i = 1; i + 1 < v.size(); i++) {
        for (int j = 0; j < i; j++) {
            for (int k = i + 1; k < v.size(); k++) {
                sum += v[i] * v[j] * v[k];
            }
        }
    }
    return sum;
}
```
+ Алгориитм почти идентичен алгоритму под номером 4
+ Функция сложности будет иметь вид f(n), где n - размер массива
+ Будем считать количество выполнений 
```cpp
sum += v[i] * v[j] * v[k];
```
+ Таким образом, сложность алгоритма будет ```куюическая```: 

$$
\sum_{i=1}^{n-2} \sum_{j=0}^{i-1} \sum_{k=i+1}^{n-1} = O(
\int_1^{n-1} \int_0^{x} \int_1^{y} 1,\mathrm{d}z\mathrm{d}y\mathrm{d}x)=O(
\int_0^{n} \int_1^{x}y,\mathrm{d}y\mathrm{d}x)=O(
\int_0^{n}\frac{n^2}{2},\mathrm{d}x)=O(
\frac{n^3}{6})
=O(n^3)
$$

---

### 6
```cpp
std::vector<int>sieve(int n) {
    std::vector<int> ans(n);
        for (int i = 2; i < n: i++) {
            if (ans[i] == 0) {
                for (int j = i; j < n; j += i) {
                    ans [j] = i;
                }
            }
        }
        return(ans);
}
```
+ Алгоритм находит максимальный простой делитель для каждого элемента веткора, и сохраняет их в новый массив. 
+ Функция сложности будет иметь вид f(n), где n - размер массива
+ Внешний цикл выполнится $n-2$ раз, в то время как внутренний $\frac{n}{i}$ раз
+ Тогда, функция сложности будет:

$$
\sum_{i=2}^{n-1} \sum_{j=i}^{\frac{n}{i}} = O(
\int_2^{n} \int_2^{n} \frac{n}{y},\mathrm{d}y\mathrm{d}x)=O(
\int_2^{n} ln(x)-ln(2),\mathrm{d}x)=O(
2n\times ln(n)+(-2ln(2)-1)n+2)=
O(n\times log(n))
$$


---

### 7

```cpp
void part(vector<int>& v, int val) {
    int i = 0, j = v.size() - 1;
    while (i <= j) {
        while (i <= j && v[i] <= val) {
            ++i;
        }
        while (i <= j && v[j] > val) {
            --j;
        }
        if (i < j)
            swap(v[i], v[j])
        ++i;
        --j;
    }
}
```
+ Алгоритм распределяет числа внутри массива на две части относительно переменной ```val```. меньшие помещает в левую часть, превосходящие - в правую.
+ Функция сложности будет иметь вид f(n), где n - размер массива
+ Внешний цикл перебирает все числа от нуля до $n-1$. Первый вложенный цикл будет работать до тех пор, пока $i$ не превзойдет $j$ или $v[i]$ элемент не окажется больше $val$ и будет увеличивать $i$. Второй вложенный цикл будет работать до тех пор, пока $i$ не превзойдет $j$ или $v[j]$ элемент не окажется меньше или равен $val$ и будет увеличивать $j$. 
+ Таким образом, сложность внешнего цикла будет составлять $O(n)$, а двавнутренних цикла в сумме выполнятся столько же раз, сколько и внешний цикл, тогда

$$
f(n) = O(n) + O(\frac{n}{2}) = O(n)
$$

---

### 8 
```cpp
struct point {
    int x;
    int y;
};
std::vector <point> convex(std::vector<point>& v) {
    std::vector<point> res;
    for (auto& p : v) {
        while (res.size() > 0
            && res.back().x * p.y >= res.back().y * p.x)
            res.pop_back();
        res.push_back(p);
    }
    return res;
}
```
+ 

---

### 9
```cpp
int foo(int a, int b) {
    int res = 1;
    while (a < b) {
        if (a % 2 == 1) {
            ++a;
        }
        if (b % 2 == 1) {
            --b;
        }
        a /= 2;
        b /= 2;
        res *= 2;
    }
    return res * a;
}

```
+ Фрагмент алгоритма построения выпуклой оболочки множества точек на плоскости. Сложность операций работы с вектором можно принять за O(1)
+ Алгоритм перебирает каждый элемент массива (пара значений для каждого элемента, координаты точек)
+ Функция сложности будет иметь вид f(n), где n - размер массива
+ Алгоритм выполнит добавление элементов в конец динамического массива ровно ```n``` раз, а удалит в худшем случае ```n``` раз, тогда 

$$
f(n)=O(n - n) = O(n)
$$



---

### 10
```cpp
int foo(int n) {
    int s = 0;
    for (int i = 1; i < n; i++) {
        for (int j = i; j % 2 == 0; j /= 2) {
            s++;
        }
    }
    return s;
}

```
+ Внешний цикл выполняется $n-1$ раз, в то время как внешний цикл выполняется иначе: он будет выполняться столько раз, сколько четных делителей у очередного индекса $i$. Получается, что второй цикл напрямую зависит от первого. 
+ Функция сложности будет иметь вид f(n), где n - число, параметр функции
+ Поэтому:

$$
f(n) = O(n \times log_2n) = (n \times logn)
$$

---


### SRC

[Анализ времени работы программы](https://www.youtube.com/watch?v=NwJjRGi2jD8)

[Сведения из математического анализа](https://www.youtube.com/watch?v=Kbv4evgLbug)

[Анализ сложности алгоритмов](https://www.youtube.com/watch?v=3LfCzB35MSU)

[Рекомендации по выполнению заданий](https://www.youtube.com/watch?v=noPTTdwx0-w)

[сложности алгоритмов](https://habr.com/ru/articles/188010/)

[Alex OS](https://www.youtube.com/watch?v=cXCuXNwzdfY&t=33s)

