# Лекция 6 | Приоритетная Очередь

#### 1. Обоснуйте корректность методов работы с кучей

+ Докажите, что если для последоваетельности элементов выполнялось свойство кучи, далее в последоваетльность был добавлен спарва новый элемент, и для него выполнена процедура пузырька, то в полученной последовательности внось будет выполняться свйосвто кучи. 

```Доказательство утверждения по индукции:```

```Предположение:``` Пусть у нас есть последовательность элементов, для которой выполняется свойство кучи перед добавлением нового элемента. После добавления нового элемента и выполнения процедуры пузырька, свойство кучи будет снова выполняться.

```База:``` Рассмотрим случай, когда исходная последовательность пуста или содержит только один элемент. В этом случае, добавление нового элемента не изменяет порядок элементов и не нарушает свойство кучи, так как в одноэлементной последовательности свойство кучи автоматически выполняется.

```Шаг индукции``` Предположим, что утверждение верно для последовательности из ```n``` элементов, где ```n >= 1```. Добавим новый элемент в последовательность и выполним процедуру пузырька, чтобы восстановить свойство кучи.

В процедуре пузырька, новый элемент будет сравниваться с его родителем и при необходимости меняться местами с ним до тех пор, пока свойство кучи не будет восстановлено. Это означает, что новый элемент будет "всплывать" вверх по куче, пока не будет занимать свое правильное место.

После завершения процедуры пузырька, свойство кучи будет снова выполняться для обновленной последовательности. Это происходит потому, что новый элемент займет правильную позицию в соответствии с порядком в куче, и свойство кучи будет сохранено.

```Таким образом```, мы доказали, что если для последовательности выполнялось свойство кучи и был добавлен новый элемент, а затем выполнена процедура пузырька, то свойство кучи будет снова выполняться для обновленной последовательности.

```
        20
      /    \
    16      15
   /  \    /  \
  10   4  12   


        20
      /    \
    18      15
   /  \    /  \
  10   4  12   16


        20
      /    \
    18      16
   /  \    /  \
  10   4  12   15

```

+ Докажите, что если для последовательности выполнялось свойсвто кучи, в этой последовательности первй элемент был изменен на некоторый другой, далее для него была выполнена операция просеивания, то в полученной последовательности вновь будет выполняться свойство кучи. 

Доказательство утверждения:

Пусть у нас есть исходная последовательность, где первый элемент был изменен на другое значение, и мы выполнили операцию просеивания (heapify) для этого элемента.

В свойстве кучи первый элемент является наибольшим элементом в последовательности. Когда мы изменяем первый элемент и выполняем операцию просеивания, мы перемещаем этот элемент на правильную позицию в куче.

В процессе просеивания мы сравниваем текущий элемент с его потомками и меняем их местами, если потомок больше текущего элемента. Это позволяет нам сохранять свойство кучи, где каждый элемент больше или равен своим потомкам.

После выполнения операции просеивания для измененного первого элемента, мы убеждаемся, что он перемещается на правильную позицию в куче, учитывая новое значение. Все потомки этого элемента также будут соответствовать свойству кучи, так как мы просеиваем их снова.

```Таким образом```, после изменения первого элемента и выполнения операции просеивания, в полученной последовательности все элементы продолжат удовлетворять свойству кучи.

Такая операция позволяет нам эффективно обновлять кучу при изменении элементов, не нарушая ее свойств.

```

         10
       /    \
      8      7
     / \    /
    5   6  4


         3
       /    \
      8      7
     / \    /
    5   6  4


         8
       /    \
      3      7
     / \    /
    5   6  4


         8
       /    \
      6      7
     / \    /
    5   3  4


```
---

#### 2. Пусть для последовательности ```a``` выполнялось свойство кучи. Предложите алгоритм для замены элемента с произвольным номером ```i``` на некоторое значение  ```a[i]=x``` так, чтобы после выполнения операции выполнялось свойство кучи. Алгоритм должен иметь максимальную сложность $O(log n)$

```cpp

if (x > parent) {
    BUBBLE_SORT_ALGORITHM(x);
}
if else (x < max(child_1, child_2)) {
    HEAPIFY_ALGORITHM(x);
}

void HEAPIFY_ALGORITHM (int x, vector<int>& v, int m, int rootIndex){...}
void BUBBLE_SORT_ALGORITHM (int x, vector<int>& v, int m, int rootIndex){...}
```

---

#### 3. Найдите максимальную сложность для каждого из двух вариантов построения кучи

```cpp
while (m > 1 && nodes[m / 2] < x) {
    nodes[m] = move(nodes[m / 2]);
    m /= 2;
}
nodes[m] = x;
```

$$
\sum_{i=1}^{n} log_2i = \int_1^{n+1} log_2i = O(log n)
$$


```cpp
while (2 * m <= n) {
    int k = 2 * m == n || nodes[2 * m] > nodes[2 * m + 1]? 2 * m : 2 * m + 1;
    if (nodes[k] <= x)
        break;
    nodes[m] = move(nodes[k]);
    m = k;
}
nodes[m] = x;
```

$$
\sum_{i=1}^{n} log_2n-log_2i = \int_1^{n+1} log_2n-log_2i = \frac{n}{ln(2)} = O(n)
$$

---

#### 4. Напиште программу на C++ с использованием приоритетной очереди. 

```txt

Сервер обрабатывает запросы. На обработку одного запроса
тратится ровно одна секунда. В начале каждой сеунды приходит 
0, 1 или 2 запроса, которые попадают в очередь. Все случаи 
равновероятны. Каждый запрос обладает приоритетом, который 
является равномерно случайным числом от 1 до 16. Далее из 
очереди сервером извлекается один запрос максимальным 
приоритетом. Если таких будет несколько, то извлекается любой.
Требуется написать программу, которая выполнить моделирование 
этого процесса 10000000 раз и найдет суммарное время ожидания 
обработки запросав для каждого приоритета. 
Для генерации случайных чисел следует использовать библиотеку 
testlib.h. Используйте шаблон программы

```

```cpp

#define _CRT_SECURE_NO_WARNINGS
// Эта директива предназначена для отключения определенных предупреждений 
// компилятора в Visual Studio, связанных с использованием небезопасных 
// функций стандартной библиотеки C. Она позволяет использовать некоторые 
// функции, которые в противном случае могут генерировать предупреждения.
#include <queue>
#include <iostream>
#include <array>
#include "testlib.h"
using namespace std;
int main() {
    setName("priority_queue");
    priority_queue<pair<int, int>> q; // Создание объекта q типа priority_queue 
    // для хранения пар элементов типа int. Очередь приоритетов используется
    // для хранения пар (приоритет, время ожидания).
    array<int, 17> cnt = { 0 }; // Количество запросов каждого приоритета
    array<long long, 17> tm = { 0 }; // Суммарное время ожидания для каждого приоритета
    // Создание массивов cnt и tm, каждый из которых содержит 17 элементов. 
    // cnt представляет количество запросов для каждого приоритета, а tm 
    // представляет суммарное время ожидания для каждого приоритета.
    // Инициализация массивов значениями 0
    int n = 10000000;
    for (int i = 0; i < n; i++) {
        int k = rnd.next(0, 2);
        for (int j = 0; j < k; j++) {
            int priority = rnd.next(1, 16); 	//Используем rnd.next(1,16)
            q.push({ priority, i }); // Добавление пары (приоритет, время ожидания) 
            // в очередь q с использованием функции push(). i представляет время 
            // ожидания текущей итерации.
        }
        if (!q.empty()) { // Проверка, является ли очередь q пустой.
            // Извлечение верхнего элемента из очереди с максимальным приоритетом 
            // с использованием функции top(). q.top().first представляет приоритет, 
            // а q.top().second представляет время ожидания. Затем обновляются 
            // суммарное время ожидания и количество запросов для данного приоритета, 
            // а затем элемент удаляется из очереди с использованием функции pop().
            tm[q.top().first] += (i - q.top().second);
            cnt[q.top().first]++;
            q.pop();
        }
    }
    for (int i = 1; i <= 16; i++)
        cout << cnt[i] << ' ' << tm[i] << endl;
    return 0;
}

```

---

#### 5. Реализуйте пирамидальную сортировку на C++, не используя функции библиотеки alhorithm. Для реализации можно использовать следующий прием

```cpp
#include <iostream>
#include <vector>
#include <random>
using namespace std;
/*
1. по заданному массиву строим кучу
2. если в куче больше одного элемента, то выполняем следующие преобразования
3. запоминаем последний элемент кучи
4. перемещаем первый элемент на место последнего
5. уменьшаем размер кучи на 1
6. восстанавливаем кучу для запомненного элемента из первой позиции при помощи операции просеивания
7. повторяем преобразования
*/
template<typename T>
void heapify(T first, int n, int i) {
    int largest = i;
    int left, right;

    while (true) {
        left = 2 * i + 1;
        right = 2 * i + 2;

        // Находим наибольший элемент среди текущего узла, левого и правого потомков
        if (left < n && first[left] > first[largest])
            largest = left;

        if (right < n && first[right] > first[largest])
            largest = right;

        // Если наибольший элемент не является текущим, меняем их местами
        // и продолжаем проверку с новым текущим узлом
        if (largest != i) {
            swap(first[i], first[largest]);
            i = largest;
        }
        else {
            break; // Куча восстановлена, выходим из цикла
        }
    }
}


template<typename T>
void pir_sort(T first, T last) {
    int n = last - first;
    --first;

    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(first, n, i);
    }

    for (int i = n - 1; i > 0; i--) {
        swap(first[0], first[i]);
        heapify(first, i, 0);
    }
}
////////////////////////
int main() {
    vector<int> a;

    for (int i = 0; i < 8; i++)
        a.push_back(rand() % 10 + 1);

    cout << "was: ";
    for (auto el: a)
        cout << el << " ";
    cout << endl;

    pir_sort(a.begin(), a.end());
    cout << "now: ";
    for (auto el: a)
        cout << el << " ";

    return 0;
}

```

---

# SRC

[Полные бинарные деревья](https://youtu.be/6yFa3PDT9PI)

[Куча](httpsw://youtu.be/oljo4Ng0b2Y)

[Приоритетная очередь](https://youtu.be/HzPcNngrz7Q)

[Использование кучи и приоритетной очереди в С++](https://youtu.be/tWCYO-IxTxU)

[Рекомендации по выполнению заданий](https://youtu.be/uhXmh3Ms_4g)
