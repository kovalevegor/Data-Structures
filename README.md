# Лекция 11 | АВЛ-деревья

### 1. Посчитайте, какое минимальное и максимальное количество узлов может быть в АВЛ-дереве высоты 3, высоты 4, и высоты 5.

Для определения минимального и максимального количества узлов в АВЛ-дереве заданной высоты, мы можем использовать следующую формулу:

Минимальное количество узлов в АВЛ-дереве высоты $h$ равно $F(h)$, где $F(h) - h+2$ число Фибоначчи.

Максимальное количество узлов в АВЛ-дереве высоты $h$ равно $2^(h+1) - 1$.

Теперь рассмотрим каждую высоту по отдельности:

`Высота 3:`
Минимальное количество узлов: $F(3) = 5$.
Максимальное количество узлов: $2^(3+1) - 1 = 15$.

`Высота 4:`
Минимальное количество узлов: $F(4) = 8$.
Максимальное количество узлов: $2^(4+1) - 1 = 31$.

`Высота 5:`
Минимальное количество узлов: $F(5) = 13$.
Максимальное количество узлов: $2^(5+1) - 1 = 63$.

Таким образом, минимальное и максимальное количество узлов в АВЛ-дереве зависит от его высоты. Высота определяет ограничения на количество узлов, и они могут варьироваться в соответствии с этими ограничениями.

---

### 2. Докажите, что при выполнении балансировки после вставнки нового занчения в АВЛ-дерево операция поворота выполняется не более одного раза

Для доказательства того, что при выполнении балансировки после вставки нового значения в АВЛ-дерево операция поворота выполняется не более одного раза, нам понадобится рассмотреть две ситуации: вставку в левое поддерево и вставку в правое поддерево.

1. Вставка в левое поддерево:
Пусть мы вставляем новое значение в левое поддерево дерева. После вставки, высота левого поддерева может увеличиться на одну единицу. Если разность высот левого и правого поддеревьев становится больше 1, то мы получаем небалансированное состояние.

+ Если новое значение было вставлено в левое поддерево левого поддерева, выполняется один правый поворот для восстановления баланса. В результате, высота дерева не изменяется, и операция поворота выполняется один раз.

+ Если новое значение было вставлено в правое поддерево левого поддерева, выполняется один левый поворот, а затем один правый поворот для восстановления баланса. В результате, высота дерева не изменяется, и операция поворота выполняется два раза, но общее количество поворотов ограничено одним.

2. Вставка в правое поддерево:
Пусть мы вставляем новое значение в правое поддерево дерева. После вставки, высота правого поддерева может увеличиться на одну единицу. Если разность высот правого и левого поддеревьев становится больше 1, то мы получаем небалансированное состояние.

+ Если новое значение было вставлено в правое поддерево правого поддерева, выполняется один левый поворот для восстановления баланса. В результате, высота дерева не изменяется, и операция поворота выполняется один раз.

+ Если новое значение было вставлено в левое поддерево правого поддерева, выполняется один правый поворот, а затем один левый поворот для восстановления баланса. В результате, высота дерева не изменяется, и операция поворота выполняется два раза, но общее количество поворотов ограничено одним.

Таким образом, в любом случае вставки нового значения в АВЛ-дерево, операция поворота выполняется не более одного раза, что доказывает данное утверждение.

---

### 3. Приведите пример АВЛ-дерерва, в котором при выполнении балансировки после удаления некоторого узла операция поворота выполняется два раза. (Дерево лучше изобразить)

Вот пример АВЛ-дерева, в котором при выполнении балансировки после удаления некоторого узла операция поворота выполняется два раза:

```
        5
       / \
      3   8
     /   / \
    2   7   9
   /
  1

```
В данном примере, если мы удалим узел со значением 7, то произойдет двукратная операция поворота для восстановления баланса. После удаления узла 7, дерево станет выглядеть следующим образом:
```
        5
       / \
      3   8
     /     \
    2       9
   /
  1
```
Далее, будет выполнен правый поворот вокруг узла 8:
```
        5
       / \
      3   9
     / \
    2   8
   /
  1
```
И наконец, будет выполнен левый поворот вокруг узла 5:
```
        3
       / \
      2   5
     /     \
    1       9
           /
          8
```
Таким образом, в данном примере после удаления узла 7 операция поворота выполняется два раза для восстановления баланса.


---

### 4. Почему для хранения высоты в АВЛ-дереве достаточно однобайтового целого числа? Не может ли оно переполниться? 

В АВЛ-дереве для хранения высоты каждого узла действительно достаточно однобайтового целого числа. Почему? Потому что высота АВЛ-дерева ограничена сверху значением $O(log n)$, где $n$ - количество узлов в дереве.

Рассмотрим, почему высота АВЛ-дерева ограничена значением $O(log n)$. В АВЛ-дереве каждый узел содержит информацию о высоте своего поддерева, и эта информация используется для балансировки дерева. При вставке или удалении узла выполняются повороты и перебалансировка, чтобы сохранить баланс дерева. Эти операции гарантируют, что разница высоты левого и правого поддерева каждого узла не превышает $1$. Таким образом, высота АВЛ-дерева ограничена логарифмической функцией от количества узлов в дереве.

Так как высота дерева ограничена значением $O(log n)$, где $n$ - количество узлов, однобайтовое целое число достаточно для хранения этого значения. Диапазон значений однобайтового целого числа составляет от $-128$ до $127$ (для знакового типа) или от $0$ до $255$ (для беззнакового типа). Поскольку высота дерева будет значительно меньше этого диапазона, нет риска переполнения.

---

#### 5. Для каких узлов дерева следует пересчитывать высоту после поворота, если балансировка происходит после вставки вершины? 

После выполнения операции поворота при балансировке АВЛ-дерева, высота должна быть пересчитана для всех узлов, которые были затронуты этой операцией. Это включает вставленную вершину, ее предка, и все узлы по пути от предка до корня дерева.

При вставке новой вершины в АВЛ-дерево, может возникнуть несбалансированность, которая нарушает условие АВЛ-дерева. Для восстановления баланса может потребоваться выполнение одного или нескольких поворотов. После каждого поворота, высота изменяется для всех узлов, которые были переставлены или переподвешены в результате этого поворота. Это необходимо для обновления значения высоты каждого узла и корректного отражения структуры дерева.

Таким образом, после каждого поворота при балансировке после вставки новой вершины, необходимо пересчитать высоту для всех узлов, затронутых этим поворотом. Это гарантирует, что высоты всех узлов будут актуальными и отражающими фактическую структуру дерева.

---

#### 6. Для какиз узлов дерева следует пересчитывать высоту после поворота, если балансировка происходит после удаления вершины?  

При балансировке после удаления вершины из АВЛ-дерева, высота должна быть пересчитана для всех узлов, которые были затронуты этой операцией. Это включает удаленную вершину, ее предка, и все узлы по пути от предка до корня дерева.

При удалении вершины из АВЛ-дерева может возникнуть несбалансированность, которая нарушает условие АВЛ-дерева. Для восстановления баланса может потребоваться выполнение одного или нескольких поворотов. После каждого поворота, высота изменяется для всех узлов, которые были переставлены или переподвешены в результате этого поворота. Это необходимо для обновления значения высоты каждого узла и корректного отражения структуры дерева.

Таким образом, после каждого поворота при балансировке после удаления вершины, необходимо пересчитать высоту для всех узлов, затронутых этим поворотом. Это гарантирует, что высоты всех узлов будут актуальными и отражающими фактическую структуру дерева.

---

#### 7. Сделайте копию файла с классом `bstree`. Далее потребуется выполнить доработку класс так, чтобы он реализовывал АВЛ-дерево. Реализуйте два статических метода `void rotate_left(basenode*)` и `void rotate_right(basenode*). Для тестирования добавьте в класс методы
```
void rotate_left(iterator it) {
        rotate_left(it node);
}
```
#### и аналогичный для правого поворота

```cpp
template <typename T>
void avl_tree<T>::rotate_left(basenode* node) {
    basenode* pivot = node->right;  // Сохраняем указатель на правого потомка узла node в переменной pivot.
    node->right = pivot->left;      // Переназначаем правого потомка узла node на левого потомка узла pivot.

    if (pivot->left != nullptr) {
        pivot->left->parent = node; // Если у узла pivot есть левый потомок, то обновляем его родителя на node.
    }

    pivot->parent = node->parent;   // Обновляем родителя узла pivot на родителя узла node.

    if (node->parent == &header) {
        header.left = pivot;        // Если node был корневым узлом, то обновляем корень дерева на pivot.
    } else if (node == node->parent->left) {
        node->parent->left = pivot;  // Если node был левым потомком своего родителя, то обновляем левого потомка родителя на pivot.
    } else {
        node->parent->right = pivot; // Иначе обновляем правого потомка родителя на pivot.
    }

    pivot->left = node;              // Делаем узел node левым потомком узла pivot.
    node->parent = pivot;            // Обновляем родителя узла node на pivot.

    // После поворота пересчитываем высоты узлов node и pivot.
    node->height = std::max(node_height(node->left), node_height(node->right)) + 1;
    pivot->height = std::max(node_height(pivot->left), node_height(pivot->right)) + 1;
}
template <typename T>
void avl_tree<T>::rotate_right(basenode* node) {
    basenode* pivot = node->left;   // Сохраняем указатель на левого потомка узла node в переменной pivot.
    node->left = pivot->right;      // Переназначаем левого потомка узла node на правого потомка узла pivot.

    if (pivot->right != nullptr) {
        pivot->right->parent = node; // Если у узла pivot есть правый потомок, то обновляем его родителя на node.
    }

    pivot->parent = node->parent;   // Обновляем родителя узла pivot на родителя узла node.

    if (node->parent == &header) {
        header.left = pivot;        // Если node был корневым узлом, то обновляем корень дерева на pivot.
    } else if (node == node->parent->right) {
        node->parent->right = pivot; // Если node был правым потомком своего родителя, то обновляем правого потомка родителя на pivot.
    } else {
        node->parent->left = pivot;  // Иначе обновляем левого потомка родителя на pivot.
    }

    pivot->right = node;             // Делаем узел node правым потомком узла pivot.
    node->parent = pivot;            // Обновляем родителя узла node на pivot.

    // После поворота пересчитываем высоты узлов node и pivot.
    node->height = std::max(node_height(node->left), node_height(node->right)) + 1;
    pivot->height = std::max(node_height(pivot->left), node_height(pivot->right)) + 1;
}
```
---

#### 8. Добавьте в класс узла следующие составляющие:

+ Добавьте в класс узла поле `height` типа `char`. Добавьте в конструктор инициализацию этого поля единицей.

```cpp
template <typename T>
class avl_tree {
    struct basenode {
        basenode* left;
        basenode* right;
        basenode* parent;
        char height;
        basenode(basenode* p) : left(nullptr), right(nullptr), parent(p), height(1) {}
    };
```

+ Добавьте статический метод `char_height(basenode*)` которая будет возвращать высоту поддерева, с учетом того, что параметр может быть пустым указателем. 

```cpp
template <typename T>
class avl_tree {
    // ...

    static char char_height(basenode* node) {
        if (node == nullptr) {
            return 0;
        }
        return static_cast<bstnode*>(node)->height;
    }

    // ...
};
```

+ Добавьте в функицю `dfs` вывод высоты текущего поддерева

```cpp
void avl_tree<T>::dfs(int dep, basenode* node) {
    if (node == nullptr)
        return;
    dfs(dep + 1, node->left);
    std::cout.width(dep * 5);
    std::cout << *iterator(node) << ' ' << (node) << ' ' << node->parent << ' ' << int(char_height(node)) << std::endl;
    dfs(dep + 1, node->right);
}
```
+ Начините разрабатывать методы `void balancing_after_insert(basenode*)` и `void balancing_after_erase(basenode*)`, которые будут пересчитывать веса вершин (пока без самой балансировки). Вставьте вызовы этих методов во все требуемые места программы. Подсказка: Над этим вопросом следует внимательно подумать. Для каждого из случаев эти методы требуется применять к различным узлам. На этом этапе реализация методов не будет различаться. 

```cpp
template <typename T>
void avl_tree<T>::balancing_after_insert(basenode* node) {
    while (node != nullptr) {
        node->weight = std::max(char_height(node->left), char_height(node->right)) + 1;
        node = node->parent;
    }
}

template <typename T>
void avl_tree<T>::balancing_after_erase(basenode* node) {
    balancing_after_insert(node);
}
```
+ Проверьте работу на прилагаемых тестах

---

#### 9. Завершите написание методов `void balancing_after_insert(basenode*)` и `void balancing_after_erase(basenode*)`, добавив в них вызовы поворотов. Обратите внимание на пересчет весов. Реализации методов будут различаться только по пересчету весов и по выходу из цикла. 

[Сбалансированные деревья](https://youtu.be/w0Y3tWPcbyg)

[АВЛ-деревья](https://youtu.be/gJSg6DizT2U)

[Изменение высоты при повороте](https://youtu.be/P8MvUmrGFQY)

[Контест номер 90](http://olymp.isu.ru/cgi-bin/new-client?contest_id=90&locale_id=1)
